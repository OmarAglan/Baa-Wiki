# توثيق هيكل شجرة النحو المجردة للغة باء (التصميم الجديد v2)

**متاح باللغة:** [العربية](#) | [English](../02_COMPILER_ARCHITECTURE/AST.md)

**الحالة: ✅ AST الأساسي مكتمل - هذا المستند يحدد التصميم المُنفذ لشجرة النحو المجردة (AST). الأولوية ٤ (تعريفات الدوال والاستدعاءات) اكتملت في ٢٠٢٥-٠٧-٠٦. جميع أنواع عقد AST الأساسية مُنفذة وعاملة.**

يوفر هذا المستند مرجعاً شاملاً لهيكل شجرة النحو المجردة (AST) المُنفذة لمترجم لغة برمجة باء. الهدف هو وضع معيار واضح لجميع مكونات AST لضمان الاتساق عبر تطبيق المترجم.

## ١. مبادئ التصميم الأساسية

1. **هيكل عقدة موحد**: جميع عناصر AST (البرنامج، الإعلانات، العبارات، التعبيرات، الأنواع) ممثلة بهيكل `BaaNode` أساسي واحد.
2. **اتحاد مُميز عبر `void* data`**: `BaaNode->kind` (تعداد `BaaNodeKind`) يحدد النوع الفعلي للعقدة. `BaaNode->data` يشير إلى هيكل بيانات محدد لذلك النوع.
3. **وصولات آمنة النوع**: سيتم توفير وحدات ماكرو لتحويل `BaaNode->data` بأمان إلى نوع البيانات المحدد الصحيح بناءً على `BaaNode->kind`.
4. **ملكية ذاكرة واضحة**:
    * جميع `BaaNode`s وهياكل `data` المرتبطة بها مخصصة ديناميكياً.
    * دالة `baa_ast_free_node(BaaNode* node)` مسؤولة عن تحرير العقدة بشكل تكراري، بياناتها المحددة، أي عقد فرعية مملوكة، وأي سلاسل نصية مضاعفة ضمن بياناتها.
5. **معالجة السلاسل النصية**: السلاسل النصية (مثل المعرفات، القيم الحرفية النصية) المخزنة في هياكل بيانات AST مضاعفة دائماً ومملوكة بواسطة عقدة AST.
6. **امتداد موقع المصدر**: كل `BaaNode` يخزن `BaaSourceSpan` يشير إلى موقع البداية والنهاية في الكود المصدر للإبلاغ الدقيق عن الأخطاء والأدوات.

## ٢. هيكل العقدة الأساسي والأنواع الأساسية

### BaaSourceLocation

يحدد نقطة في الكود المصدر.

```c
typedef struct {
    const wchar_t* filename; // مؤشر إلى سلسلة اسم الملف (الكنسية)
    size_t line;             // رقم السطر (يبدأ من ١)
    size_t column;           // رقم العمود (يبدأ من ١)
} BaaSourceLocation;
```

### BaaSourceSpan

يحدد امتداد من الكود المصدر من موقع بداية إلى موقع نهاية.

```c
typedef struct {
    BaaSourceLocation start;
    BaaSourceLocation end;
} BaaSourceSpan;
```

### BaaNodeKind

تعداد موحد لجميع أنواع عقد AST.

```c
typedef enum {
    // هيكل البرنامج
    BAA_NODE_KIND_PROGRAM,          // البرنامج على المستوى الأعلى (data: BaaProgramData)
    BAA_NODE_KIND_FUNCTION_DEF,     // تعريف الدالة (data: BaaFunctionDefData)
    BAA_NODE_KIND_PARAMETER,        // معامل الدالة (data: BaaParameterData)

    // العبارات
    BAA_NODE_KIND_EXPR_STMT,        // عبارة التعبير (data: BaaExprStmtData)
    BAA_NODE_KIND_BLOCK_STMT,       // كتلة من العبارات (data: BaaBlockStmtData)
    BAA_NODE_KIND_IF_STMT,          // عبارة إذا (data: BaaIfStmtData)
    BAA_NODE_KIND_WHILE_STMT,       // حلقة طالما (data: BaaWhileStmtData)
    BAA_NODE_KIND_FOR_STMT,         // حلقة لكل (data: BaaForStmtData)
    BAA_NODE_KIND_RETURN_STMT,      // عبارة إرجع (data: BaaReturnStmtData)
    BAA_NODE_KIND_VAR_DECL_STMT,    // عبارة إعلان متغير (data: BaaVarDeclData)
    BAA_NODE_KIND_BREAK_STMT,       // عبارة توقف (data: NULL أو BaaBreakStmtData إذا كانت التسميات مدعومة)
    BAA_NODE_KIND_CONTINUE_STMT,    // عبارة استمر (data: NULL أو BaaContinueStmtData إذا كانت التسميات مدعومة)

    // التعبيرات
    BAA_NODE_KIND_LITERAL_EXPR,     // قيمة حرفية (data: BaaLiteralExprData)
    BAA_NODE_KIND_IDENTIFIER_EXPR,  // معرف/مرجع متغير (data: BaaIdentifierExprData)
    BAA_NODE_KIND_UNARY_EXPR,       // عملية أحادية (data: BaaUnaryExprData)
    BAA_NODE_KIND_BINARY_EXPR,      // عملية ثنائية (data: BaaBinaryExprData)
    BAA_NODE_KIND_CALL_EXPR,        // استدعاء دالة (data: BaaCallExprData)
    BAA_NODE_KIND_ASSIGN_EXPR,      // إسناد (data: BaaAssignExprData)
    BAA_NODE_KIND_CAST_EXPR,        // تحويل النوع (data: BaaCastExprData)
    BAA_NODE_KIND_ARRAY_LITERAL_EXPR, // قيمة حرفية للمصفوفة مثل [1,2,3] (data: BaaArrayLiteralExprData)
    BAA_NODE_KIND_INDEX_EXPR,       // فهرسة المصفوفة مثل arr[idx] (data: BaaIndexExprData)

    // تمثيلات الأنواع (صيغة النوع المُحللة)
    BAA_NODE_KIND_TYPE,             // يمثل مواصفة نوع (data: BaaTypeAstData)

    // الأدوات
    BAA_NODE_KIND_UNKNOWN,          // عقدة نائبة أو خطأ
} BaaNodeKind;
```

### BaaNode

اللبنة الأساسية لـ AST.

```c
typedef struct BaaNode {
    BaaNodeKind kind;       // النوع المحدد لعقدة AST هذه
    BaaSourceSpan span;     // امتداد موقع المصدر لهذه العقدة
    void* data;             // مؤشر إلى هيكل بيانات محدد للنوع
} BaaNode;
```

### معدلات عقدة AST

معدلات مثل `ثابت` (const)، `مستقر` (static)، `مضمن` (inline)، `مقيد` (restrict) ستُخزن كقناع بت في هياكل البيانات المحددة ذات الصلة.

```c
typedef uint32_t BaaAstNodeModifiers;
#define BAA_MOD_NONE     (0)
#define BAA_MOD_CONST    (1 << 0) // ثابت
#define BAA_MOD_STATIC   (1 << 1) // مستقر
#define BAA_MOD_INLINE   (1 << 2) // مضمن
#define BAA_MOD_RESTRICT (1 << 3) // مقيد
```

## ٣. وحدات ماكرو الوصول الآمنة النوع

```c
// مثال: الوصول إلى البيانات لعقدة تعبير حرفي
#define BaaNodeGetLiteralData(node) \
    (((node) && (node)->kind == BAA_NODE_KIND_LITERAL_EXPR) ? (BaaLiteralExprData*)((node)->data) : NULL)

// مثال: الوصول إلى البيانات لعقدة عبارة إذا
#define BaaNodeGetIfStmtData(node) \
    (((node) && (node)->kind == BAA_NODE_KIND_IF_STMT) ? (BaaIfStmtData*)((node)->data) : NULL)
```

## ٤. هياكل بيانات عقدة محددة

### ٤.١ بيانات هيكل البرنامج

**BaaProgramData (لـ `BAA_NODE_KIND_PROGRAM`)**

```c
typedef struct {
    BaaNode** top_level_declarations; // مصفوفة ديناميكية من BaaNode* (تعريفات دوال، إعلانات متغيرات عامة)
    size_t count;
    size_t capacity;
} BaaProgramData;
```

**BaaFunctionDefData (لـ `BAA_NODE_KIND_FUNCTION_DEF`)**

```c
typedef struct {
    wchar_t* name;                      // اسم الدالة المضاعف
    BaaAstNodeModifiers modifiers;      // مثل static، inline
    BaaNode* return_type_node;          // BaaNode* من النوع BAA_NODE_KIND_TYPE
    BaaNode** parameters;               // مصفوفة ديناميكية من BaaNode* (كل من النوع BAA_NODE_KIND_PARAMETER)
    size_t parameter_count;
    size_t parameter_capacity;
    BaaNode* body;                      // BaaNode* من النوع BAA_NODE_KIND_BLOCK_STMT
    bool is_variadic;                   // للمتغيرات بأسلوب C (...)
} BaaFunctionDefData;
```

**BaaParameterData (لـ `BAA_NODE_KIND_PARAMETER`)**

```c
typedef struct {
    wchar_t* name;              // اسم المعامل المضاعف
    BaaNode* type_node;         // BaaNode* من النوع BAA_NODE_KIND_TYPE
} BaaParameterData;
```

### ٤.٢ هياكل بيانات العبارات

**BaaExprStmtData (لـ `BAA_NODE_KIND_EXPR_STMT`)**

```c
typedef struct {
    BaaNode* expression; // التعبير (BaaNode* بنوع تعبير)
} BaaExprStmtData;
```

**BaaBlockStmtData (لـ `BAA_NODE_KIND_BLOCK_STMT`)**

```c
typedef struct {
    BaaNode** statements;   // مصفوفة ديناميكية من BaaNode* (أنواع عبارات)
    size_t count;
    size_t capacity;
} BaaBlockStmtData;
```

**BaaVarDeclData (لـ `BAA_NODE_KIND_VAR_DECL_STMT`)**

```c
typedef struct {
    wchar_t* name;              // اسم المتغير المضاعف
    BaaAstNodeModifiers modifiers; // مثل const، static
    BaaNode* type_node;         // BaaNode* من النوع BAA_NODE_KIND_TYPE
    BaaNode* initializer_expr;  // تعبير التهيئة الاختياري (BaaNode* بنوع تعبير)
} BaaVarDeclData;
```

**BaaIfStmtData (لـ `BAA_NODE_KIND_IF_STMT`)**

```c
typedef struct {
    BaaNode* condition_expr;    // تعبير الشرط
    BaaNode* then_stmt;         // عبارة أو كتلة لفرع 'إذا'
    BaaNode* else_stmt;         // عبارة أو كتلة اختيارية لفرع 'وإلا' (يمكن أن تكون NULL)
} BaaIfStmtData;
```

### ٤.٣ هياكل بيانات التعبيرات

**BaaLiteralExprData (لـ `BAA_NODE_KIND_LITERAL_EXPR`)**

```c
typedef enum {
    BAA_LITERAL_KIND_BOOL,
    BAA_LITERAL_KIND_INT,
    BAA_LITERAL_KIND_FLOAT,
    BAA_LITERAL_KIND_CHAR,
    BAA_LITERAL_KIND_STRING,
    BAA_LITERAL_KIND_NULL,
} BaaLiteralKind;

typedef struct {
    BaaLiteralKind literal_kind;
    union {
        bool bool_value;
        long long int_value;      // لاستيعاب جميع أحجام الأعداد الصحيحة
        double float_value;       // لاستيعاب جميع أحجام الأعداد العائمة
        wchar_t char_value;
        wchar_t* string_value;    // سلسلة نصية مضاعفة
    } value;
    BaaType* determined_type;   // BaaType* كنسي محدد بواسطة المحلل النحوي بناءً على شكل الحرفي واللواحق
} BaaLiteralExprData;
```

**BaaIdentifierExprData (لـ `BAA_NODE_KIND_IDENTIFIER_EXPR`)**

```c
typedef struct {
    wchar_t* name;              // اسم المعرف المضاعف
} BaaIdentifierExprData;
```

**BaaUnaryExprData (لـ `BAA_NODE_KIND_UNARY_EXPR`)**

```c
typedef enum { /* UNARY_PLUS, UNARY_MINUS, LOGICAL_NOT, BITWISE_NOT, ... */ } BaaUnaryOperatorKind;
typedef struct {
    BaaUnaryOperatorKind op_kind;
    BaaNode* operand_expr;
} BaaUnaryExprData;
```

**BaaBinaryExprData (لـ `BAA_NODE_KIND_BINARY_EXPR`)**

```c
typedef enum { /* ADD, SUB, MUL, DIV, EQUAL, LESS_THAN, LOGICAL_AND, ... */ } BaaBinaryOperatorKind;
typedef struct {
    BaaBinaryOperatorKind op_kind;
    BaaNode* left_expr;
    BaaNode* right_expr;
} BaaBinaryExprData;
```

**BaaCallExprData (لـ `BAA_NODE_KIND_CALL_EXPR`)**

```c
typedef struct {
    BaaNode* callee_expr;       // التعبير المُستدعى (عادة معرف)
    BaaNode** arguments;        // مصفوفة ديناميكية من تعبيرات الوسائط
    size_t argument_count;
    size_t argument_capacity;
} BaaCallExprData;
```

### ٤.٤ بيانات عقدة تمثيل النوع

**BaaTypeAstData (لـ `BAA_NODE_KIND_TYPE`)**

```c
typedef enum {
    BAA_TYPE_AST_KIND_PRIMITIVE, // مثل "عدد_صحيح"، "حرف"
    BAA_TYPE_AST_KIND_ARRAY,
    BAA_TYPE_AST_KIND_POINTER,   // مستقبلي
    BAA_TYPE_AST_KIND_USER_DEFINED, // مستقبلي، لأسماء struct/enum
} BaaTypeAstKind;

typedef struct {
    BaaTypeAstKind type_ast_kind;
    union {
        struct { // لـ BAA_TYPE_AST_KIND_PRIMITIVE
            wchar_t* name; // مضاعف (مثل L"عدد_صحيح")
        } primitive;
        struct { // لـ BAA_TYPE_AST_KIND_ARRAY
            BaaNode* element_type_node; // BaaNode* من النوع BAA_NODE_KIND_TYPE
            BaaNode* size_expr;         // اختياري: تعبير BaaNode* لحجم المصفوفة
        } array;
    } specifier;
} BaaTypeAstData;
```

## ٥. دوال إدارة الذاكرة

```c
// دوال الإنشاء
BaaNode* baa_ast_new_program_node(BaaSourceSpan span);
BaaNode* baa_ast_new_literal_int_node(BaaSourceSpan span, long long value, BaaType* determined_type);
BaaNode* baa_ast_new_function_def_node(BaaSourceSpan span, wchar_t* name, BaaAstNodeModifiers modifiers);
BaaNode* baa_ast_new_call_expr_node(BaaSourceSpan span, BaaNode* callee_expr);

// دالة التدمير
void baa_ast_free_node(BaaNode* node); // دالة التحرير الرئيسية
```

`baa_ast_free_node` ستوزع داخلياً على دوال تحرير بيانات محددة بناءً على `node->kind`.

## ٦. اجتياز AST (نمط الزائر)

```c
typedef struct BaaASTVisitor BaaASTVisitor;

struct BaaASTVisitor {
    // ترجع bool: true لمتابعة الاجتياز، false للتوقف
    bool (*pre_visit_node)(BaaNode* node, void* user_data, BaaASTVisitor* self);
    void (*post_visit_node)(BaaNode* node, void* user_data, BaaASTVisitor* self);
};

// دالة الاجتياز
void baa_ast_traverse(BaaNode* root_node, BaaASTVisitor* visitor, void* user_data);
```

## ٧. أمثلة الاستخدام

### إنشاء AST بسيط

```c
#include "baa/ast/ast.h"

int main() {
    // إنشاء برنامج بسيط: عدد_صحيح الرئيسية() { إرجع ٠؛ }
    
    BaaSourceSpan span = { /* معلومات الموقع */ };
    
    // إنشاء عقدة البرنامج
    BaaNode* program = baa_ast_new_program_node(span);
    
    // إنشاء تعريف الدالة الرئيسية
    BaaNode* main_func = baa_ast_new_function_def_node(span, L"الرئيسية", BAA_MOD_NONE);
    
    // إضافة نوع الإرجاع (عدد_صحيح)
    BaaNode* return_type = baa_ast_new_type_node(span, BAA_TYPE_AST_KIND_PRIMITIVE, L"عدد_صحيح");
    BaaFunctionDefData* func_data = BaaNodeGetFunctionDefData(main_func);
    func_data->return_type_node = return_type;
    
    // إنشاء جسم الدالة
    BaaNode* body = baa_ast_new_block_stmt_node(span);
    
    // إنشاء عبارة الإرجاع
    BaaNode* return_stmt = baa_ast_new_return_stmt_node(span);
    BaaNode* zero_literal = baa_ast_new_literal_int_node(span, 0, NULL);
    BaaReturnStmtData* return_data = BaaNodeGetReturnStmtData(return_stmt);
    return_data->return_expr = zero_literal;
    
    // تجميع AST
    baa_ast_add_statement_to_block(body, return_stmt);
    func_data->body = body;
    baa_ast_add_declaration_to_program(program, main_func);
    
    printf("تم إنشاء AST بنجاح!\n");
    
    // تحرير الذاكرة
    baa_ast_free_node(program);
    
    return 0;
}
```

### اجتياز AST

```c
#include "baa/ast/ast.h"

bool print_visitor_pre(BaaNode* node, void* user_data, BaaASTVisitor* self) {
    int* depth = (int*)user_data;
    
    // طباعة المسافة البادئة
    for (int i = 0; i < *depth; i++) {
        printf("  ");
    }
    
    // طباعة نوع العقدة
    switch (node->kind) {
        case BAA_NODE_KIND_PROGRAM:
            printf("برنامج\n");
            break;
        case BAA_NODE_KIND_FUNCTION_DEF: {
            BaaFunctionDefData* data = BaaNodeGetFunctionDefData(node);
            wprintf(L"تعريف دالة: %ls\n", data->name);
            break;
        }
        case BAA_NODE_KIND_LITERAL_EXPR: {
            BaaLiteralExprData* data = BaaNodeGetLiteralData(node);
            if (data->literal_kind == BAA_LITERAL_KIND_INT) {
                printf("قيمة حرفية عددية: %lld\n", data->value.int_value);
            }
            break;
        }
        default:
            printf("عقدة أخرى\n");
            break;
    }
    
    (*depth)++;
    return true; // متابعة الاجتياز
}

void print_visitor_post(BaaNode* node, void* user_data, BaaASTVisitor* self) {
    int* depth = (int*)user_data;
    (*depth)--;
}

void print_ast(BaaNode* ast) {
    BaaASTVisitor visitor = {
        .pre_visit_node = print_visitor_pre,
        .post_visit_node = print_visitor_post
    };
    
    int depth = 0;
    baa_ast_traverse(ast, &visitor, &depth);
}
```

### معالجة استدعاءات الدوال

```c
void process_function_call(BaaNode* call_node) {
    if (call_node->kind != BAA_NODE_KIND_CALL_EXPR) {
        return;
    }
    
    BaaCallExprData* call_data = BaaNodeGetCallExprData(call_node);
    
    // معالجة المُستدعى
    if (call_data->callee_expr->kind == BAA_NODE_KIND_IDENTIFIER_EXPR) {
        BaaIdentifierExprData* id_data = BaaNodeGetIdentifierData(call_data->callee_expr);
        wprintf(L"استدعاء دالة: %ls\n", id_data->name);
    }
    
    // معالجة الوسائط
    printf("عدد الوسائط: %zu\n", call_data->argument_count);
    for (size_t i = 0; i < call_data->argument_count; i++) {
        printf("  وسيطة %zu: ", i + 1);
        BaaNode* arg = call_data->arguments[i];
        
        if (arg->kind == BAA_NODE_KIND_LITERAL_EXPR) {
            BaaLiteralExprData* lit_data = BaaNodeGetLiteralData(arg);
            if (lit_data->literal_kind == BAA_LITERAL_KIND_INT) {
                printf("عدد صحيح: %lld\n", lit_data->value.int_value);
            }
        } else if (arg->kind == BAA_NODE_KIND_IDENTIFIER_EXPR) {
            BaaIdentifierExprData* id_data = BaaNodeGetIdentifierData(arg);
            wprintf(L"معرف: %ls\n", id_data->name);
        }
    }
}
```

## ٨. أفضل الممارسات

### إدارة الذاكرة
1. **تحرير دائم**: تأكد من استدعاء `baa_ast_free_node()` لجميع عقد AST المُنشأة
2. **تجنب التحرير المزدوج**: لا تحرر العقد الفرعية يدوياً، `baa_ast_free_node()` يتعامل مع ذلك
3. **التحقق من NULL**: تحقق دائماً من إرجاع NULL من دوال الإنشاء

### بناء AST
1. **معلومات الموقع**: اضرب دائماً معلومات موقع دقيقة لكل عقدة
2. **التحقق من النوع**: استخدم وحدات ماكرو الوصول الآمنة النوع
3. **الاتساق**: حافظ على اتساق في كيفية بناء أنواع العقد المشابهة

### الأداء
1. **تجميع التخصيصات**: فكر في تجميع التخصيصات للعقد الصغيرة
2. **تجنب النسخ غير الضروري**: استخدم مؤشرات للعقد الفرعية
3. **الذاكرة المحلية**: استخدم تخصيص مكدس للبنى المؤقتة عندما يكون ذلك ممكناً

## ٩. التطوير المستقبلي

### الميزات المخططة
- **دعم أنواع إضافية**: مؤشرات، مصفوفات، هياكل
- **معلومات تصحيح محسنة**: معلومات موقع أكثر تفصيلاً
- **تحسين الذاكرة**: تقنيات تجميع وإعادة استخدام محسنة
- **أدوات تصحيح**: أدوات لتصور وتصحيح AST

### التكامل
- **التحليل الدلالي**: ربط العقد بجدول الرموز
- **توليد الكود**: اجتياز AST لتوليد كود الهدف
- **التحسين**: تمرات تحسين على AST

---

*للحصول على معلومات حول كيفية بناء AST من المحلل النحوي، راجع `docs/02_COMPILER_ARCHITECTURE/PARSER.md`.*
*للحصول على أمثلة تفصيلية لاستخدام AST، راجع `docs/_assets/examples/`.*
