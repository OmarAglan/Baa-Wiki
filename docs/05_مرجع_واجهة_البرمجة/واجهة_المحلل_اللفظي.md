# واجهة برمجة المحلل اللفظي

## نظرة عامة

المحلل اللفظي (Lexer) هو المكون المسؤول عن تحويل تدفق النص المُعالج مسبقاً إلى تدفق من الرموز (Tokens). يدعم المحلل اللفظي لباء الكلمات المفتاحية العربية، الأرقام العربية-الهندية، وتسلسلات الهروب العربية المخصصة.

## الملفات الرئيسية

- `include/baa/lexer/lexer.h` - الواجهة العامة
- `src/lexer/lexer.c` - التنفيذ الرئيسي
- `src/lexer/lexer_internal.h` - التعريفات الداخلية

## الهياكل والأنواع

### `BaaLexer`

```c
typedef struct BaaLexer BaaLexer;
```

الهيكل الرئيسي للمحلل اللفظي. يحتوي على حالة التحليل والإعدادات.

### `BaaToken`

```c
typedef struct {
    BaaTokenKind kind;          // نوع الرمز
    BaaSourceLocation location; // موقع الرمز في المصدر
    const wchar_t* lexeme;      // النص الأصلي للرمز
    size_t lexeme_length;       // طول النص
    union {
        long long int_value;    // للأعداد الصحيحة
        double float_value;     // للأعداد العشرية
        wchar_t char_value;     // للحروف الحرفية
        bool bool_value;        // للقيم المنطقية
    } value;                    // القيمة المحولة
} BaaToken;
```

يمثل رمز واحد من المحلل اللفظي مع جميع المعلومات المرتبطة به.

### `BaaTokenKind`

```c
typedef enum {
    // رموز خاصة
    BAA_TOKEN_EOF,              // نهاية الملف
    BAA_TOKEN_NEWLINE,          // سطر جديد
    BAA_TOKEN_WHITESPACE,       // مسافة بيضاء
    BAA_TOKEN_COMMENT,          // تعليق
    
    // المعرفات والكلمات المفتاحية
    BAA_TOKEN_IDENTIFIER,       // معرف
    BAA_TOKEN_KEYWORD_IF,       // إذا
    BAA_TOKEN_KEYWORD_ELSE,     // وإلا
    BAA_TOKEN_KEYWORD_WHILE,    // طالما
    BAA_TOKEN_KEYWORD_FOR,      // لكل
    BAA_TOKEN_KEYWORD_RETURN,   // إرجع
    BAA_TOKEN_KEYWORD_BREAK,    // توقف
    BAA_TOKEN_KEYWORD_CONTINUE, // استمر
    
    // الأنواع
    BAA_TOKEN_KEYWORD_INT,      // عدد_صحيح
    BAA_TOKEN_KEYWORD_FLOAT,    // عدد_حقيقي
    BAA_TOKEN_KEYWORD_CHAR,     // حرف
    BAA_TOKEN_KEYWORD_BOOL,     // منطقي
    BAA_TOKEN_KEYWORD_VOID,     // فراغ
    
    // المعدلات
    BAA_TOKEN_KEYWORD_CONST,    // ثابت
    BAA_TOKEN_KEYWORD_STATIC,   // مستقر
    BAA_TOKEN_KEYWORD_EXTERN,   // خارجي
    BAA_TOKEN_KEYWORD_INLINE,   // مضمن
    
    // القيم الحرفية
    BAA_TOKEN_INTEGER_LITERAL,  // قيمة حرفية صحيحة
    BAA_TOKEN_FLOAT_LITERAL,    // قيمة حرفية عشرية
    BAA_TOKEN_CHAR_LITERAL,     // قيمة حرفية حرف
    BAA_TOKEN_STRING_LITERAL,   // قيمة حرفية نصية
    BAA_TOKEN_BOOL_LITERAL,     // قيمة حرفية منطقية
    
    // العمليات
    BAA_TOKEN_PLUS,             // +
    BAA_TOKEN_MINUS,            // -
    BAA_TOKEN_MULTIPLY,         // *
    BAA_TOKEN_DIVIDE,           // /
    BAA_TOKEN_MODULO,           // %
    BAA_TOKEN_ASSIGN,           // =
    BAA_TOKEN_EQUAL,            // ==
    BAA_TOKEN_NOT_EQUAL,        // !=
    BAA_TOKEN_LESS_THAN,        // <
    BAA_TOKEN_GREATER_THAN,     // >
    BAA_TOKEN_LESS_EQUAL,       // <=
    BAA_TOKEN_GREATER_EQUAL,    // >=
    BAA_TOKEN_LOGICAL_AND,      // &&
    BAA_TOKEN_LOGICAL_OR,       // ||
    BAA_TOKEN_LOGICAL_NOT,      // !
    
    // العلامات
    BAA_TOKEN_DOT,              // . (منهي الجملة)
    BAA_TOKEN_COMMA,            // ,
    BAA_TOKEN_SEMICOLON,        // ;
    BAA_TOKEN_LEFT_PAREN,       // (
    BAA_TOKEN_RIGHT_PAREN,      // )
    BAA_TOKEN_LEFT_BRACE,       // {
    BAA_TOKEN_RIGHT_BRACE,      // }
    BAA_TOKEN_LEFT_BRACKET,     // [
    BAA_TOKEN_RIGHT_BRACKET,    // ]
    
    // رموز خطأ
    BAA_TOKEN_ERROR,            // رمز خطأ
    BAA_TOKEN_UNKNOWN           // رمز غير معروف
} BaaTokenKind;
```

جميع أنواع الرموز المدعومة في المحلل اللفظي.

## الدوال العامة

### إنشاء وتهيئة المحلل اللفظي

#### `baa_lexer_create`

```c
BaaLexer* baa_lexer_create(const wchar_t* input, size_t input_length);
```

**الوصف**: ينشئ محلل لفظي جديد من تدفق نص UTF-16LE.

**المعاملات**:
- `input`: مؤشر إلى تدفق النص المراد تحليله
- `input_length`: طول التدفق بالحروف

**القيمة المرجعة**: مؤشر إلى المحلل اللفظي الجديد، أو `NULL` في حالة الفشل

**مثال**:
```c
const wchar_t* source = L"عدد_صحيح س = ١٠.";
BaaLexer* lexer = baa_lexer_create(source, wcslen(source));
```

#### `baa_lexer_create_from_file`

```c
BaaLexer* baa_lexer_create_from_file(const char* filename);
```

**الوصف**: ينشئ محلل لفظي من ملف مصدر.

**المعاملات**:
- `filename`: مسار الملف المراد قراءته

**القيمة المرجعة**: مؤشر إلى المحلل اللفظي، أو `NULL` في حالة الفشل

**مثال**:
```c
BaaLexer* lexer = baa_lexer_create_from_file("program.baa");
```

### تحليل الرموز

#### `baa_lexer_next_token`

```c
BaaToken baa_lexer_next_token(BaaLexer* lexer);
```

**الوصف**: يحلل ويرجع الرمز التالي من التدفق.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي

**القيمة المرجعة**: الرمز التالي

**مثال**:
```c
BaaToken token = baa_lexer_next_token(lexer);
if (token.kind == BAA_TOKEN_KEYWORD_INT) {
    printf("وجدت كلمة مفتاحية: عدد_صحيح\n");
}
```

#### `baa_lexer_peek_token`

```c
BaaToken baa_lexer_peek_token(BaaLexer* lexer);
```

**الوصف**: يطلع على الرمز التالي دون استهلاكه.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي

**القيمة المرجعة**: الرمز التالي

#### `baa_lexer_skip_whitespace`

```c
void baa_lexer_skip_whitespace(BaaLexer* lexer);
```

**الوصف**: يتجاوز المسافات البيضاء والأسطر الجديدة.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي

### معلومات الموقع

#### `baa_lexer_get_location`

```c
BaaSourceLocation baa_lexer_get_location(BaaLexer* lexer);
```

**الوصف**: يرجع الموقع الحالي في المصدر.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي

**القيمة المرجعة**: موقع المصدر الحالي

### تنظيف الذاكرة

#### `baa_lexer_destroy`

```c
void baa_lexer_destroy(BaaLexer* lexer);
```

**الوصف**: ينظف ويحرر ذاكرة المحلل اللفظي.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي المراد تدميره

**مثال**:
```c
baa_lexer_destroy(lexer);
lexer = NULL;
```

## دوال مساعدة

### `baa_token_kind_to_string`

```c
const char* baa_token_kind_to_string(BaaTokenKind kind);
```

**الوصف**: يحول نوع الرمز إلى نص للتصحيح.

**المعاملات**:
- `kind`: نوع الرمز

**القيمة المرجعة**: نص يمثل نوع الرمز

### `baa_token_is_keyword`

```c
bool baa_token_is_keyword(BaaTokenKind kind);
```

**الوصف**: يتحقق إذا كان الرمز كلمة مفتاحية.

**المعاملات**:
- `kind`: نوع الرمز

**القيمة المرجعة**: `true` إذا كان كلمة مفتاحية

### `baa_token_is_literal`

```c
bool baa_token_is_literal(BaaTokenKind kind);
```

**الوصف**: يتحقق إذا كان الرمز قيمة حرفية.

**المعاملات**:
- `kind`: نوع الرمز

**القيمة المرجعة**: `true` إذا كان قيمة حرفية

## الميزات الخاصة

### دعم الأرقام العربية-الهندية

يدعم المحلل اللفظي الأرقام العربية-الهندية (`٠-٩`) بجانب الأرقام الغربية:

```c
// أمثلة مدعومة
"١٢٣"        // عدد صحيح
"٣٫١٤"       // عدد عشري مع فاصل عربي
"١٫٢٣أ٤"     // ترميز علمي عربي
"٠x١ا٢ب"     // سادس عشري مع أرقام عربية
```

### تسلسلات الهروب العربية

```c
// تسلسلات هروب مخصصة لباء
"\س"         // سطر جديد (\n)
"\م"         // تاب (\t)
"\ر"         // إرجاع العربة (\r)
"\ص"         // حرف فارغ (\0)
"\يXXXX"      // Unicode escape
"\هـHH"       // Hex byte escape
```

### دعم التعليقات

```c
// تعليق سطر واحد
/* تعليق متعدد الأسطر */
/** تعليق توثيقي */
```

## أمثلة الاستخدام

### مثال شامل

```c
#include "baa/lexer/lexer.h"
#include <stdio.h>

int main() {
    // الكود المراد تحليله
    const wchar_t* source = L"عدد_صحيح العدد = ١٠.\n"
                           L"إذا (العدد > ٥) {\n"
                           L"    اطبع(\"كبير\").\n"
                           L"}";
    
    // إنشاء المحلل اللفظي
    BaaLexer* lexer = baa_lexer_create(source, wcslen(source));
    if (!lexer) {
        fprintf(stderr, "خطأ في إنشاء المحلل اللفظي\n");
        return 1;
    }
    
    // تحليل جميع الرموز
    BaaToken token;
    do {
        token = baa_lexer_next_token(lexer);
        
        // طباعة معلومات الرمز
        printf("الرمز: %s", baa_token_kind_to_string(token.kind));
        if (token.lexeme) {
            printf(" - النص: %ls", token.lexeme);
        }
        if (token.kind == BAA_TOKEN_INTEGER_LITERAL) {
            printf(" - القيمة: %lld", token.value.int_value);
        }
        printf(" - الموقع: %d:%d\n", 
               token.location.line, token.location.column);
               
    } while (token.kind != BAA_TOKEN_EOF);
    
    // تنظيف الذاكرة
    baa_lexer_destroy(lexer);
    return 0;
}
```

### مثال معالجة الأخطاء

```c
BaaToken token = baa_lexer_next_token(lexer);
if (token.kind == BAA_TOKEN_ERROR) {
    fprintf(stderr, "خطأ لفظي في السطر %d، العمود %d: %ls\n",
            token.location.line, token.location.column, token.lexeme);
    // معالجة الخطأ...
}
```

### مثال تجاهل المسافات والتعليقات

```c
BaaToken token;
do {
    token = baa_lexer_next_token(lexer);
} while (token.kind == BAA_TOKEN_WHITESPACE || 
         token.kind == BAA_TOKEN_NEWLINE ||
         token.kind == BAA_TOKEN_COMMENT);

// الآن token يحتوي على أول رمز مفيد
```

## معالجة الأخطاء

### أنواع الأخطاء الشائعة

1. **حرف غير معروف**: `BAA_TOKEN_ERROR` مع الحرف في `lexeme`
2. **سلسلة نصية غير مُنهية**: `BAA_TOKEN_ERROR` مع النص الجزئي
3. **رقم سادس عشري غير صحيح**: `BAA_TOKEN_ERROR` مع النص
4. **تسلسل هروب غير صحيح**: `BAA_TOKEN_ERROR` مع التسلسل

### استراتيجية الاسترداد

المحلل اللفظي يواصل التحليل بعد الأخطاء عبر:
- تجاهل الحرف الخاطئ والمتابعة
- إرجاع رمز خطأ مع معلومات الموقع
- الحفاظ على تدفق الرموز للتحليل النحوي

## الاختبارات

### اختبارات الوحدة

```bash
# تشغيل اختبارات المحلل اللفظي
./build/tests/unit/lexer/test_lexer
./build/tests/unit/lexer/test_lexer_arabic
./build/tests/unit/lexer/test_number_parser
```

### ملفات اختبار

- `tests/resources/lexer_test_cases/lexer_test_suite.baa`
- `tests/resources/lexer_test_cases/whitespace_newlines.baa`

---

**واجهة المحلل اللفظي توفر أساساً قوياً وموثوقاً لتحليل كود لغة باء مع دعم كامل للميزات العربية الفريدة.**
