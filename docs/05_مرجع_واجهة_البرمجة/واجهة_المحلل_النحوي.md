# واجهة برمجة المحلل النحوي

## نظرة عامة

المحلل النحوي (Parser) هو المكون المسؤول عن تحويل تدفق الرموز من المحلل اللفظي إلى شجرة نحو مجردة (AST). يستخدم المحلل النحوي لباء خوارزمية النزول التكراري (Recursive Descent) مع معالجة شاملة للأخطاء.

## الملفات الرئيسية

- `include/baa/parser/parser.h` - الواجهة العامة
- `src/parser/parser.c` - التنفيذ الرئيسي
- `src/parser/parser_internal.h` - التعريفات الداخلية
- `src/parser/expression_parser.c` - تحليل التعبيرات
- `src/parser/statement_parser.c` - تحليل الجمل
- `src/parser/declaration_parser.c` - تحليل الإعلانات

## الهياكل والأنواع

### `BaaParser`

```c
typedef struct BaaParser BaaParser;
```

الهيكل الرئيسي للمحلل النحوي. يحتوي على حالة التحليل وتدفق الرموز.

### `BaaParseResult`

```c
typedef struct {
    BaaNode* node;              // شجرة النحو المجردة المُنتجة
    BaaDiagnosticList* diagnostics; // قائمة الأخطاء والتحذيرات
    bool success;               // هل نجح التحليل؟
} BaaParseResult;
```

نتيجة عملية التحليل النحوي مع الأخطاء والعقدة المُنتجة.

### `BaaParseOptions`

```c
typedef struct {
    bool skip_whitespace;       // تجاهل المسافات البيضاء
    bool skip_comments;         // تجاهل التعليقات
    bool recover_from_errors;   // الاسترداد من الأخطاء
    bool strict_mode;           // وضع صارم للتحليل
} BaaParseOptions;
```

خيارات التحليل النحوي.

## الدوال العامة

### إنشاء وتهيئة المحلل النحوي

#### `baa_parser_create`

```c
BaaParser* baa_parser_create(BaaLexer* lexer, const BaaParseOptions* options);
```

**الوصف**: ينشئ محلل نحوي جديد من محلل لفظي.

**المعاملات**:
- `lexer`: مؤشر إلى المحلل اللفظي
- `options`: خيارات التحليل (اختياري، يمكن أن يكون `NULL`)

**القيمة المرجعة**: مؤشر إلى المحلل النحوي الجديد، أو `NULL` في حالة الفشل

**مثال**:
```c
BaaLexer* lexer = baa_lexer_create(source, length);
BaaParseOptions options = {
    .skip_whitespace = true,
    .skip_comments = true,
    .recover_from_errors = true,
    .strict_mode = false
};
BaaParser* parser = baa_parser_create(lexer, &options);
```

#### `baa_parser_create_from_string`

```c
BaaParser* baa_parser_create_from_string(const wchar_t* source, size_t length);
```

**الوصف**: ينشئ محلل نحوي مباشرة من نص المصدر.

**المعاملات**:
- `source`: نص المصدر
- `length`: طول النص

**القيمة المرجعة**: مؤشر إلى المحلل النحوي

### تحليل البرنامج

#### `baa_parser_parse_program`

```c
BaaParseResult baa_parser_parse_program(BaaParser* parser);
```

**الوصف**: يحلل البرنامج الكامل وينتج شجرة النحو المجردة.

**المعاملات**:
- `parser`: مؤشر إلى المحلل النحوي

**القيمة المرجعة**: نتيجة التحليل مع شجرة النحو المجردة

**مثال**:
```c
BaaParseResult result = baa_parser_parse_program(parser);
if (result.success) {
    printf("التحليل نجح! عدد العقد: %zu\n", 
           baa_node_count_children(result.node));
} else {
    printf("فشل التحليل مع %zu خطأ\n", 
           result.diagnostics->count);
}
```

### تحليل التعبيرات

#### `baa_parser_parse_expression`

```c
BaaParseResult baa_parser_parse_expression(BaaParser* parser);
```

**الوصف**: يحلل تعبير واحد.

**المعاملات**:
- `parser`: مؤشر إلى المحلل النحوي

**القيمة المرجعة**: نتيجة التحليل مع عقدة التعبير

#### `baa_parser_parse_primary_expression`

```c
BaaParseResult baa_parser_parse_primary_expression(BaaParser* parser);
```

**الوصف**: يحلل تعبير أولي (قيم حرفية، معرفات، أقواس).

#### `baa_parser_parse_binary_expression`

```c
BaaParseResult baa_parser_parse_binary_expression(BaaParser* parser, int min_precedence);
```

**الوصف**: يحلل تعبير ثنائي مع أولوية محددة.

**المعاملات**:
- `parser`: مؤشر إلى المحلل النحوي
- `min_precedence`: الأولوية الدنيا للعمليات

### تحليل الجمل

#### `baa_parser_parse_statement`

```c
BaaParseResult baa_parser_parse_statement(BaaParser* parser);
```

**الوصف**: يحلل جملة واحدة.

#### `baa_parser_parse_if_statement`

```c
BaaParseResult baa_parser_parse_if_statement(BaaParser* parser);
```

**الوصف**: يحلل جملة شرطية (`إذا`/`وإلا`).

#### `baa_parser_parse_while_statement`

```c
BaaParseResult baa_parser_parse_while_statement(BaaParser* parser);
```

**الوصف**: يحلل جملة حلقة (`طالما`).

#### `baa_parser_parse_for_statement`

```c
BaaParseResult baa_parser_parse_for_statement(BaaParser* parser);
```

**الوصف**: يحلل جملة حلقة (`لكل`).

#### `baa_parser_parse_return_statement`

```c
BaaParseResult baa_parser_parse_return_statement(BaaParser* parser);
```

**الوصف**: يحلل جملة إرجاع (`إرجع`).

#### `baa_parser_parse_block_statement`

```c
BaaParseResult baa_parser_parse_block_statement(BaaParser* parser);
```

**الوصف**: يحلل كتلة جمل (`{...}`).

### تحليل الإعلانات

#### `baa_parser_parse_declaration`

```c
BaaParseResult baa_parser_parse_declaration(BaaParser* parser);
```

**الوصف**: يحلل إعلان (متغير أو دالة).

#### `baa_parser_parse_variable_declaration`

```c
BaaParseResult baa_parser_parse_variable_declaration(BaaParser* parser);
```

**الوصف**: يحلل إعلان متغير.

#### `baa_parser_parse_function_definition`

```c
BaaParseResult baa_parser_parse_function_definition(BaaParser* parser);
```

**الوصف**: يحلل تعريف دالة.

#### `baa_parser_parse_parameter_list`

```c
BaaParseResult baa_parser_parse_parameter_list(BaaParser* parser);
```

**الوصف**: يحلل قائمة معاملات الدالة.

### تحليل الأنواع

#### `baa_parser_parse_type_specifier`

```c
BaaParseResult baa_parser_parse_type_specifier(BaaParser* parser);
```

**الوصف**: يحلل محدد نوع (`عدد_صحيح`, `عدد_حقيقي`, إلخ).

## معلومات المحلل النحوي

#### `baa_parser_current_token`

```c
BaaToken baa_parser_current_token(BaaParser* parser);
```

**الوصف**: يرجع الرمز الحالي.

#### `baa_parser_peek_token`

```c
BaaToken baa_parser_peek_token(BaaParser* parser);
```

**الوصف**: يطلع على الرمز التالي دون استهلاكه.

#### `baa_parser_advance`

```c
void baa_parser_advance(BaaParser* parser);
```

**الوصف**: ينتقل إلى الرمز التالي.

#### `baa_parser_expect_token`

```c
bool baa_parser_expect_token(BaaParser* parser, BaaTokenKind expected);
```

**الوصف**: يتحقق من وجود رمز معين ويستهلكه.

**المعاملات**:
- `parser`: مؤشر إلى المحلل النحوي
- `expected`: نوع الرمز المتوقع

**القيمة المرجعة**: `true` إذا كان الرمز متطابق

## معالجة الأخطاء

#### `baa_parser_add_error`

```c
void baa_parser_add_error(BaaParser* parser, const char* message);
```

**الوصف**: يضيف خطأ إلى قائمة التشخيصات.

#### `baa_parser_synchronize`

```c
void baa_parser_synchronize(BaaParser* parser);
```

**الوصف**: يزامن المحلل النحوي بعد خطأ للاسترداد.

### تنظيف الذاكرة

#### `baa_parser_destroy`

```c
void baa_parser_destroy(BaaParser* parser);
```

**الوصف**: ينظف ويحرر ذاكرة المحلل النحوي.

#### `baa_parse_result_destroy`

```c
void baa_parse_result_destroy(BaaParseResult* result);
```

**الوصف**: ينظف نتيجة التحليل.

## دوال مساعدة

### `baa_parser_is_at_end`

```c
bool baa_parser_is_at_end(BaaParser* parser);
```

**الوصف**: يتحقق إذا كان المحلل النحوي وصل لنهاية التدفق.

### `baa_parser_match_token`

```c
bool baa_parser_match_token(BaaParser* parser, BaaTokenKind kind);
```

**الوصف**: يتحقق من تطابق الرمز الحالي مع نوع معين.

### `baa_parser_get_precedence`

```c
int baa_parser_get_precedence(BaaTokenKind operator_token);
```

**الوصف**: يرجع أولوية عملية معينة.

## أمثلة الاستخدام

### مثال شامل

```c
#include "baa/parser/parser.h"
#include "baa/lexer/lexer.h"
#include <stdio.h>

int main() {
    // الكود المراد تحليله
    const wchar_t* source = L"عدد_صحيح جمع(عدد_صحيح أ، عدد_صحيح ب) {\n"
                           L"    إرجع أ + ب.\n"
                           L"}\n"
                           L"\n"
                           L"عدد_صحيح رئيسية() {\n"
                           L"    عدد_صحيح النتيجة = جمع(١٠، ٢٠).\n"
                           L"    إرجع النتيجة.\n"
                           L"}";
    
    // إنشاء المحلل اللفظي
    BaaLexer* lexer = baa_lexer_create(source, wcslen(source));
    if (!lexer) {
        fprintf(stderr, "خطأ في إنشاء المحلل اللفظي\n");
        return 1;
    }
    
    // إنشاء المحلل النحوي
    BaaParseOptions options = {
        .skip_whitespace = true,
        .skip_comments = true,
        .recover_from_errors = true,
        .strict_mode = false
    };
    
    BaaParser* parser = baa_parser_create(lexer, &options);
    if (!parser) {
        fprintf(stderr, "خطأ في إنشاء المحلل النحوي\n");
        baa_lexer_destroy(lexer);
        return 1;
    }
    
    // تحليل البرنامج
    BaaParseResult result = baa_parser_parse_program(parser);
    
    if (result.success) {
        printf("✅ التحليل النحوي نجح!\n");
        printf("عدد العقد الرئيسية: %zu\n", 
               baa_node_count_children(result.node));
        
        // طباعة شجرة النحو المجردة
        baa_ast_print(result.node, stdout);
        
    } else {
        printf("❌ فشل التحليل النحوي\n");
        printf("عدد الأخطاء: %zu\n", result.diagnostics->count);
        
        // طباعة الأخطاء
        for (size_t i = 0; i < result.diagnostics->count; i++) {
            BaaDiagnostic* diag = &result.diagnostics->items[i];
            printf("خطأ في السطر %d، العمود %d: %s\n",
                   diag->location.line, diag->location.column, 
                   diag->message_ar ? diag->message_ar : diag->message_en);
        }
    }
    
    // تنظيف الذاكرة
    baa_parse_result_destroy(&result);
    baa_parser_destroy(parser);
    baa_lexer_destroy(lexer);
    
    return result.success ? 0 : 1;
}
```

### مثال تحليل تعبير واحد

```c
const wchar_t* expr_source = L"(أ + ب) * ٢";
BaaLexer* lexer = baa_lexer_create(expr_source, wcslen(expr_source));
BaaParser* parser = baa_parser_create(lexer, NULL);

BaaParseResult result = baa_parser_parse_expression(parser);
if (result.success) {
    printf("تعبير صحيح: ");
    baa_ast_print_expression(result.node, stdout);
    printf("\n");
}

baa_parse_result_destroy(&result);
baa_parser_destroy(parser);
baa_lexer_destroy(lexer);
```

### مثال معالجة أخطاء متقدمة

```c
BaaParseResult result = baa_parser_parse_program(parser);

// فحص نتيجة التحليل
if (!result.success) {
    printf("عُثر على %zu مشكلة:\n", result.diagnostics->count);
    
    for (size_t i = 0; i < result.diagnostics->count; i++) {
        BaaDiagnostic* diag = &result.diagnostics->items[i];
        
        // طباعة حسب مستوى الخطورة
        switch (diag->level) {
            case BAA_DIAGNOSTIC_ERROR:
                printf("❌ خطأ: ");
                break;
            case BAA_DIAGNOSTIC_WARNING:
                printf("⚠️  تحذير: ");
                break;
            case BAA_DIAGNOSTIC_NOTE:
                printf("ℹ️  ملاحظة: ");
                break;
        }
        
        printf("%s (السطر %d، العمود %d)\n",
               diag->message_ar ? diag->message_ar : diag->message_en,
               diag->location.line, diag->location.column);
        
        // طباعة السياق إذا كان متوفراً
        if (diag->context.start.line == diag->context.end.line) {
            printf("    %.*ls\n", 
                   (int)(diag->context.end.column - diag->context.start.column),
                   /* pointer to source line */);
        }
    }
}
```

## أولوية العمليات

يستخدم المحلل النحوي جدول أولوية يدعم جميع عمليات لغة باء:

| الأولوية | العملية | الترابط | الوصف |
|----------|---------|---------|--------|
| 15 | `()` `[]` `::` | يسار | استدعاء، فهرسة، وصول عضو |
| 14 | `++` `--` (لاحق) | يسار | زيادة/إنقاص لاحق |
| 13 | `++` `--` `+` `-` `!` (بادئ) | يمين | أحادي بادئ |
| 12 | `*` `/` `%` | يسار | ضربي |
| 11 | `+` `-` | يسار | جمعي |
| 10 | `<<` `>>` | يسار | إزاحة بتية |
| 9 | `<` `>` `<=` `>=` | يسار | مقارنة |
| 8 | `==` `!=` | يسار | مساواة |
| 7 | `&` | يسار | و بتي |
| 6 | `^` | يسار | أو حصري بتي |
| 5 | `\|` | يسار | أو بتي |
| 4 | `&&` | يسار | و منطقي |
| 3 | `\|\|` | يسار | أو منطقي |
| 2 | `? :` | يمين | شرطي ثلاثي |
| 1 | `=` `+=` `-=` إلخ | يمين | تعيين |

## الاختبارات

### اختبارات الوحدة

```bash
# تشغيل اختبارات المحلل النحوي
./build/tests/unit/parser/test_parser_core
./build/tests/unit/parser/test_parser_expressions
./build/tests/unit/parser/test_parser_statements
```

### ملفات اختبار

- `tests/resources/parser_tests/valid_simple.baa`
- `tests/resources/parser_tests/lexical_error_test.baa`

---

**واجهة المحلل النحوي توفر تحليل نحوي قوي ومرن مع دعم كامل للنحو العربي ومعالجة أخطاء ذكية.**
